drop_na(DTHDY, DTH, all_of(cov_OS)) %>%   # ← 同时要求所有协变量非缺失
droplevels()
## 2.3a 设参考水平（建议：EMPLOY=UNK；HER2=Negative；ECOG=0）
if ("UNK" %in% levels(dat_os$EMPLOY)) dat_os$EMPLOY <- fct_relevel(dat_os$EMPLOY, "UNK", after = 0)
if ("Negative" %in% levels(dat_os$HER2)) dat_os$HER2 <- fct_relevel(dat_os$HER2, "Negative", after = 0)
dat_os$ECOG <- factor(dat_os$ECOG)
if ("0" %in% levels(dat_os$ECOG)) dat_os$ECOG <- fct_relevel(dat_os$ECOG, "0", after = 0)
## 2.4 设计矩阵（因子→哑变量），去截距与零方差
X_os <- model.matrix(~ . , data = dat_os %>% select(all_of(cov_OS)))
X_os <- X_os[, colnames(X_os)!="(Intercept)", drop = FALSE]
keep  <- apply(X_os, 2, function(z) sd(z, na.rm = TRUE) > 0)
X_os  <- X_os[, keep, drop = FALSE]
## 2.5 Cox 拟合
y_os  <- Surv(dat_os$DTHDY, dat_os$DTH)
fit_os <- coxph(y_os ~ X_os)
## 2.6 结果表（HR/CI/p）
tab_os <- tidy(fit_os, exponentiate = TRUE, conf.int = TRUE) %>%
mutate(term = sub("^X_os|^X_", "", term)) %>%
select(term, HR = estimate, CI.low = conf.low, CI.high = conf.high, p.value)
summary(fit_os)
## 2.7 把“参考组”也加进表用于展示（HR=1）
## 2.7 把“参考组”也加进表用于展示（HR=1）
## 2.7 把“参考组”也加进表用于展示（HR=1）
fac_vars_os <- names(Filter(\(v) is.factor(dat_os[[v]]), as.list(cov_OS)))
ref_rows_os <- map_dfr(fac_vars_os, \(v) tibble(
term   = paste0(v, levels(dat_os[[v]])[1], " (ref)"),
HR     = 1, CI.low = 1, CI.high = 1, p.value = NA_real_
))
tab_os_disp <- bind_rows(tab_os, ref_rows_os)
View(tab_os_disp)
## 2.8 森林图（含参考组；参考组不画误差条）
p_os <- ggplot(tab_os_disp,
aes(y = reorder(term, HR, function(z) ifelse(is.na(z), 1, z)),
x = HR)) +
geom_point() +
geom_errorbarh(
data = filter(tab_os_disp, !is.na(CI.low)),
aes(xmin = CI.low, xmax = CI.high), height = 0.2
) +
geom_vline(xintercept = 1, linetype = 2, linewidth = 0.4) +
scale_x_log10() +
labs(x = "Hazard Ratio (log scale)", y = NULL,
title = "OS Forest Plot (with reference levels)") +
theme_classic(base_size = 12)
print(tab_os_disp)
print(p_os)
## 2.7 把“参考组”也加进表用于展示（HR=1）
fac_vars_os <- names(Filter(\(v) is.factor(dat_os[[v]]), as.list(cov_OS)))
ref_rows_os <- map_dfr(fac_vars_os, \(v) tibble(
term   = paste0(v, levels(dat_os[[v]])[1], " (ref)"),
HR     = 1, CI.low = 1, CI.high = 1, p.value = NA_real_
))
tab_os_disp <- bind_rows(tab_os, ref_rows_os)
tab_os_disp
ref_rows_os
# 1) 明确把这些（你期望是分类的）列强制为因子
dat_os <- dat_os %>%
mutate(
STAGE  = as.factor(STAGE),
ARM    = as.factor(ARM),
EMPLOY = as.factor(EMPLOY),
ECOG   = as.factor(ECOG),
HER2   = as.factor(HER2)
# LESION1 如果是0/1计数，不需要ref；若本意是分类也可 as.factor(LESION1)
)
# 2) 设定参考水平（可选，根据你的选择）
if ("UNK" %in% levels(dat_os$EMPLOY))   dat_os$EMPLOY <- forcats::fct_relevel(dat_os$EMPLOY, "UNK", after = 0)
if ("Negative" %in% levels(dat_os$HER2)) dat_os$HER2   <- forcats::fct_relevel(dat_os$HER2, "Negative", after = 0)
if ("0" %in% levels(dat_os$ECOG))        dat_os$ECOG   <- forcats::fct_relevel(dat_os$ECOG, "0", after = 0)
# 3) 看看哪些列真的是 factor（很关键）
sapply(dat_os[cov_OS], class)
lapply(dat_os[c("STAGE","ARM","EMPLOY","ECOG","HER2")], levels)
# 4) 只从“确实是因子”的变量生成参考行
fac_vars_os <- cov_OS[sapply(cov_OS, function(v) is.factor(dat_os[[v]]))]
fac_vars_os
ref_rows_os <- purrr::map_dfr(
fac_vars_os,
function(v) tibble::tibble(
term    = paste0(v, levels(dat_os[[v]])[1], " (ref)"),
HR      = 1,
CI.low  = 1,
CI.high = 1,
p.value = NA_real_
)
)
# 5) 合并并查看
tab_os_disp <- dplyr::bind_rows(tab_os, ref_rows_os)
print(tab_os_disp)
setwd("~/Desktop/Zhou Lab/Breast Cancer PRO project/Analysis/wwanbing/output/TTFD+Covariates")
Merge_TTFD <- read_csv("Merged_PRO_TTFD_01OCT2025.csv")
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
## 2.2 -999 清洗（其他列 -999→NA；不在此步显式 UNK）
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
## 2.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_os <- dat_os %>%
filter(DTHDY != -999, DTH != -999, DTHDY > 0) %>%
drop_na(DTHDY, DTH, all_of(cov_OS)) %>%
droplevels()
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
cov_OS  <- c("STAGE", "ARM", "EMPLOY", "LESION1", "ECOG", "HER2")
cov_PFS <- c("STAGE", "AGE", "ARM", "MENOS", "ECOG", "ERS", "HER2")
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
## 2.2 -999 清洗（其他列 -999→NA；不在此步显式 UNK）
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
## 2.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_os <- dat_os %>%
filter(DTHDY != -999, DTH != -999, DTHDY > 0) %>%
drop_na(DTHDY, DTH, all_of(cov_OS)) %>%
droplevels()
## 2.3a 设参考（若存在这些水平）
if ("UNK" %in% levels(dat_os$EMPLOY))   dat_os$EMPLOY <- fct_relevel(dat_os$EMPLOY, "UNK", after = 0)
if ("Negative" %in% levels(dat_os$HER2)) dat_os$HER2   <- fct_relevel(dat_os$HER2, "Negative", after = 0)
dat_os$ECOG <- factor(dat_os$ECOG)
if ("0" %in% levels(dat_os$ECOG))        dat_os$ECOG   <- fct_relevel(dat_os$ECOG, "0", after = 0)
## 2.4 分类/连续类型确认（确保这些列是因子）
dat_os <- dat_os %>%
mutate(
STAGE  = as.factor(STAGE),
ARM    = as.factor(ARM),
EMPLOY = as.factor(EMPLOY),
ECOG   = as.factor(ECOG),
HER2   = as.factor(HER2)
# LESION1 如果本来是连续，就不要 factor；保留数值型即可
)
## 2.5 设计矩阵（去截距与零方差）
X_os <- model.matrix(~ ., data = dat_os %>% select(all_of(cov_OS)))
X_os <- X_os[, colnames(X_os) != "(Intercept)", drop = FALSE]
keep  <- apply(X_os, 2, function(z) sd(z, na.rm = TRUE) > 0)
X_os  <- X_os[, keep, drop = FALSE]
## 2.6 合成建模数据并拟合 Cox
stopifnot(nrow(dat_os) == nrow(X_os))
df_os_model <- cbind(dat_os[, c("DTHDY","DTH")], as.data.frame(X_os))
df_os_model <- df_os_model[, colSums(!is.na(df_os_model)) > 0, drop = FALSE]
df_os_model <- df_os_model[complete.cases(df_os_model), , drop = FALSE]
fit_os <- coxph(Surv(DTHDY, DTH) ~ ., data = df_os_model)
summary(fit_os)
install.packages("emmeans")
library(emmeans)
###cell mean code
## ==== 协变量集合 ====
cov_OS_fct  <- c("STAGE", "ARM", "EMPLOY", "ECOG", "HER2") # 因子
cov_OS_num  <- c("LESION1")                                 # 连续
cov_OS      <- c(cov_OS_fct, cov_OS_num)
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
## 2.2 -999 → NA
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else na_if(as.character(.x), "-999")
}))
## 2.3 保留完整行（时间/结局/所有协变量非缺失）
dat_os <- dat_os %>%
filter(DTHDY != -999, DTH != -999, DTHDY > 0) %>%
drop_na(DTHDY, DTH, all_of(cov_OS)) %>%
droplevels()
## 2.4 明确类型：因子 vs 连续
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS_fct), ~ factor(.x))) %>%
mutate(across(all_of(cov_OS_num),  ~ as.numeric(.x)))
## 2.5 Cox（cell-mean coding：无截距，对因子用 0+）
# 公式：Surv ~ 0 + (因子们) + (连续们)
form_os <- as.formula(
paste0("Surv(DTHDY, DTH) ~ 0 + ",
paste(cov_OS_fct, collapse = " + "),
if (length(cov_OS_num) > 0) paste0(" + ", paste(cov_OS_num, collapse = " + ")) else "")
)
fit_os <- coxph(form_os, data = dat_os)
## 2.6 结果表（每个水平自身的 HR）
tab_os <- tidy(fit_os, exponentiate = TRUE, conf.int = TRUE) %>%
transmute(term,
HR = estimate, CI.low = conf.low, CI.high = conf.high, p.value)
print(tab_os)
summary(fit_os)
## （可选）如果你想看任意两水平的 HR（A vs B），例如 HER2：
emm_her2_os <- emmeans(fit_os, ~ HER2)
pairs_her2_os <- summary(contrast(emm_her2_os, "pairwise"), type = "response")
as.data.frame(pairs_her2_os)[, c("contrast","ratio","asymp.LCL","asymp.UCL","p.value")]
cov_OS  <- c("STAGE", "ARM", "EMPLOY", "LESION1", "ECOG", "HER2")
cov_PFS <- c("STAGE", "AGE", "ARM", "MENOS", "ECOG", "ERS", "HER2")
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
## 2.2 -999 清洗（其他列 -999→NA；不在此步显式 UNK）
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
## 2.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_os <- dat_os %>%
filter(DTHDY != -999, DTH != -999, DTHDY > 0) %>%
drop_na(DTHDY, DTH, all_of(cov_OS)) %>%
droplevels()
## 2.3a 设参考（若存在这些水平）
if ("UNK" %in% levels(dat_os$EMPLOY))   dat_os$EMPLOY <- fct_relevel(dat_os$EMPLOY, "UNK", after = 0)
if ("Negative" %in% levels(dat_os$HER2)) dat_os$HER2   <- fct_relevel(dat_os$HER2, "Negative", after = 0)
dat_os$ECOG <- factor(dat_os$ECOG)
if ("0" %in% levels(dat_os$ECOG))        dat_os$ECOG   <- fct_relevel(dat_os$ECOG, "0", after = 0)
## 2.4 分类/连续类型确认（确保这些列是因子）
dat_os <- dat_os %>%
mutate(
STAGE  = as.factor(STAGE),
ARM    = as.factor(ARM),
EMPLOY = as.factor(EMPLOY),
ECOG   = as.factor(ECOG),
HER2   = as.factor(HER2)
# LESION1 如果本来是连续，就不要 factor；保留数值型即可
)
## 2.5 设计矩阵（去截距与零方差）
X_os <- model.matrix(~ ., data = dat_os %>% select(all_of(cov_OS)))
X_os <- X_os[, colnames(X_os) != "(Intercept)", drop = FALSE]
keep  <- apply(X_os, 2, function(z) sd(z, na.rm = TRUE) > 0)
X_os  <- X_os[, keep, drop = FALSE]
## 2.6 合成建模数据并拟合 Cox
stopifnot(nrow(dat_os) == nrow(X_os))
df_os_model <- cbind(dat_os[, c("DTHDY","DTH")], as.data.frame(X_os))
df_os_model <- df_os_model[, colSums(!is.na(df_os_model)) > 0, drop = FALSE]
df_os_model <- df_os_model[complete.cases(df_os_model), , drop = FALSE]
fit_os <- coxph(Surv(DTHDY, DTH) ~ ., data = df_os_model)
# summary(fit_os)
## 2.7 结果表（HR/95%CI/p）
tab_os <- tidy(fit_os, exponentiate = TRUE, conf.int = TRUE) %>%
mutate(term = sub("^X_", "", term)) %>%
select(term, HR = estimate, CI.low = conf.low, CI.high = conf.high, p.value)
## 2.8 加参考组（对每个因子，第一水平视为 ref，HR=1）
fac_vars_os <- cov_OS[sapply(cov_OS, function(v) is.factor(dat_os[[v]]))]
ref_rows_os <- map_dfr(fac_vars_os, function(v) tibble(
term   = paste0(v, levels(dat_os[[v]])[1], " (ref)"),
HR     = 1, CI.low = 1, CI.high = 1, p.value = NA_real_
))
tab_os_disp <- bind_rows(tab_os, ref_rows_os)
## 2.9 森林图（含参考组；参考组不画误差条）
p_os <- ggplot(tab_os_disp,
aes(y = reorder(term, HR, function(z) ifelse(is.na(z), 1, z)),
x = HR)) +
geom_point() +
geom_errorbarh(
data = filter(tab_os_disp, !is.na(CI.low)),
aes(xmin = CI.low, xmax = CI.high), height = 0.2
) +
geom_vline(xintercept = 1, linetype = 2, linewidth = 0.4) +
scale_x_log10() +
labs(x = "Hazard Ratio (log scale)", y = NULL,
title = "OS Forest Plot (with reference levels)") +
theme_classic(base_size = 12)
print(tab_os_disp)
print(p_os)
## 3.1 取字段
dat_pfs <- Merge_TTFD %>%
select(UID, PFSDY, PFS, all_of(cov_PFS)) %>%
distinct()
## 3.2 -999 清洗（字符转因子；数值 -999 -> NA）
dat_pfs <- dat_pfs %>%
mutate(across(all_of(cov_PFS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
## 3.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_pfs <- dat_pfs %>%
filter(PFSDY != -999, PFS != -999, PFSDY > 0) %>%
drop_na(PFSDY, PFS, all_of(cov_PFS)) %>%
droplevels()
## 3.3a 设置参考水平（若这些水平存在）
if ("Negative" %in% levels(dat_pfs$HER2)) dat_pfs$HER2 <- fct_relevel(dat_pfs$HER2, "Negative", after = 0)
dat_pfs$ECOG <- factor(dat_pfs$ECOG)
if ("0" %in% levels(dat_pfs$ECOG))        dat_pfs$ECOG <- fct_relevel(dat_pfs$ECOG, "0", after = 0)
dat_pfs$ERS  <- factor(dat_pfs$ERS)
if ("0" %in% levels(dat_pfs$ERS))         dat_pfs$ERS  <- fct_relevel(dat_pfs$ERS,  "0", after = 0)
## 3.4 明确类型（因子 vs 连续）
dat_pfs <- dat_pfs %>%
mutate(
STAGE = as.factor(STAGE),
ARM   = as.factor(ARM),
MENOS = as.factor(MENOS),
ECOG  = as.factor(ECOG),
ERS   = as.factor(ERS),
HER2  = as.factor(HER2),
AGE   = as.numeric(AGE)  # AGE 连续
)
## 3.5 设计矩阵（去截距与零方差）
X_pfs <- model.matrix(~ ., data = dat_pfs %>% select(all_of(cov_PFS)))
X_pfs <- X_pfs[, colnames(X_pfs) != "(Intercept)", drop = FALSE]
keep   <- apply(X_pfs, 2, function(z) sd(z, na.rm = TRUE) > 0)
X_pfs  <- X_pfs[, keep, drop = FALSE]
## 3.6 合成建模数据并拟合 Cox
stopifnot(nrow(dat_pfs) == nrow(X_pfs))
df_pfs_model <- cbind(dat_pfs[, c("PFSDY","PFS")], as.data.frame(X_pfs))
df_pfs_model <- df_pfs_model[, colSums(!is.na(df_pfs_model)) > 0, drop = FALSE]
df_pfs_model <- df_pfs_model[complete.cases(df_pfs_model), , drop = FALSE]
fit_pfs <- coxph(Surv(PFSDY, PFS) ~ ., data = df_pfs_model)
# summary(fit_pfs)
## 3.7 结果表（HR/95%CI/p）
tab_pfs <- tidy(fit_pfs, exponentiate = TRUE, conf.int = TRUE) %>%
mutate(term = sub("^X_", "", term)) %>%
select(term, HR = estimate, CI.low = conf.low, CI.high = conf.high, p.value)
## 3.8 加参考组（对每个因子，第一水平视为 ref，HR=1）
fac_vars_pfs <- cov_PFS[sapply(cov_PFS, function(v) is.factor(dat_pfs[[v]]))]
ref_rows_pfs <- purrr::map_dfr(fac_vars_pfs, function(v) tibble::tibble(
term   = paste0(v, levels(dat_pfs[[v]])[1], " (ref)"),
HR     = 1, CI.low = 1, CI.high = 1, p.value = NA_real_
))
tab_pfs_disp <- dplyr::bind_rows(tab_pfs, ref_rows_pfs)
## 3.9 森林图（含参考组；参考组不画误差条）
p_pfs <- ggplot(tab_pfs_disp,
aes(y = reorder(term, HR, function(z) ifelse(is.na(z), 1, z)),
x = HR)) +
geom_point() +
geom_errorbarh(
data = dplyr::filter(tab_pfs_disp, !is.na(CI.low)),
aes(xmin = CI.low, xmax = CI.high),
height = 0.2
) +
geom_vline(xintercept = 1, linetype = 2, linewidth = 0.4) +
scale_x_log10() +
labs(x = "Hazard Ratio (log scale)", y = NULL,
title = "PFS Forest Plot (with reference levels)") +
theme_classic(base_size = 12)
print(tab_pfs_disp)
print(p_pfs)
summary(fit_pfs)
## 3.1 取字段
dat_pfs <- Merge_TTFD %>%
select(UID, PFSDY, PFS, all_of(cov_PFS)) %>%
distinct()
## 3.2 -999 清洗（字符转因子；数值 -999 -> NA）
dat_pfs <- dat_pfs %>%
mutate(across(all_of(cov_PFS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
## 3.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_pfs <- dat_pfs %>%
filter(PFSDY != -999, PFS != -999, PFSDY > 0) %>%
drop_na(PFSDY, PFS, all_of(cov_PFS)) %>%
droplevels()
if ("UNK" %in% levels(dat_pfs$MENOS))         dat_pfs$MENOS  <- fct_relevel(dat_pfs$MENOS,  "UNK", after = 0)
## 3.4 明确类型（因子 vs 连续）
dat_pfs <- dat_pfs %>%
mutate(
STAGE = as.factor(STAGE),
ARM   = as.factor(ARM),
MENOS = as.factor(MENOS),
ECOG  = as.factor(ECOG),
ERS   = as.factor(ERS),
HER2  = as.factor(HER2),
AGE   = as.numeric(AGE)  # AGE 连续
)
## 3.5 设计矩阵（去截距与零方差）
X_pfs <- model.matrix(~ ., data = dat_pfs %>% select(all_of(cov_PFS)))
X_pfs <- X_pfs[, colnames(X_pfs) != "(Intercept)", drop = FALSE]
keep   <- apply(X_pfs, 2, function(z) sd(z, na.rm = TRUE) > 0)
X_pfs  <- X_pfs[, keep, drop = FALSE]
## 3.6 合成建模数据并拟合 Cox
stopifnot(nrow(dat_pfs) == nrow(X_pfs))
df_pfs_model <- cbind(dat_pfs[, c("PFSDY","PFS")], as.data.frame(X_pfs))
df_pfs_model <- df_pfs_model[, colSums(!is.na(df_pfs_model)) > 0, drop = FALSE]
df_pfs_model <- df_pfs_model[complete.cases(df_pfs_model), , drop = FALSE]
fit_pfs <- coxph(Surv(PFSDY, PFS) ~ ., data = df_pfs_model)
## 3.7 结果表（HR/95%CI/p）
tab_pfs <- tidy(fit_pfs, exponentiate = TRUE, conf.int = TRUE) %>%
mutate(term = sub("^X_", "", term)) %>%
select(term, HR = estimate, CI.low = conf.low, CI.high = conf.high, p.value)
summary(fit_pfs)
## 3.8 加参考组（对每个因子，第一水平视为 ref，HR=1）
fac_vars_pfs <- cov_PFS[sapply(cov_PFS, function(v) is.factor(dat_pfs[[v]]))]
ref_rows_pfs <- purrr::map_dfr(fac_vars_pfs, function(v) tibble::tibble(
term   = paste0(v, levels(dat_pfs[[v]])[1], " (ref)"),
HR     = 1, CI.low = 1, CI.high = 1, p.value = NA_real_
))
tab_pfs_disp <- dplyr::bind_rows(tab_pfs, ref_rows_pfs)
## 3.9 森林图（含参考组；参考组不画误差条）
p_pfs <- ggplot(tab_pfs_disp,
aes(y = reorder(term, HR, function(z) ifelse(is.na(z), 1, z)),
x = HR)) +
geom_point() +
geom_errorbarh(
data = dplyr::filter(tab_pfs_disp, !is.na(CI.low)),
aes(xmin = CI.low, xmax = CI.high),
height = 0.2
) +
geom_vline(xintercept = 1, linetype = 2, linewidth = 0.4) +
scale_x_log10() +
labs(x = "Hazard Ratio (log scale)", y = NULL,
title = "PFS Forest Plot (with reference levels)") +
theme_classic(base_size = 12)
print(tab_pfs_disp)
print(p_pfs)
tab_os_disp
setwd("/Users/wangwanbing/Desktop/Zhou Lab/Breast Cancer PRO project/Analysis/data")
write_csv(tab_pfs_disp, "PFS_forest_table_with_ref.csv")
write_csv(tab_os_disp, "OS_forest_table_with_ref.csv")
library(tidyverse)
library(survival)
library(broom)
library(survminer)   # ggforest, 简洁好用
library(emmeans)
setwd("~/Desktop/Zhou Lab/Breast Cancer PRO project/Analysis/wwanbing/output/TTFD+Covariates")
Merge_TTFD <- read_csv("Merged_PRO_TTFD_01OCT2025.csv")
cov_OS  <- c("STAGE", "ARM", "EMPLOY", "LESION1", "ECOG", "HER2")
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
## 2.2 -999 清洗（其他列 -999→NA；不在此步显式 UNK）
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
## 2.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_os <- dat_os %>%
filter(DTHDY != -999, DTH != -999, DTHDY > 0) %>%
drop_na(DTHDY, DTH, all_of(cov_OS)) %>%
droplevels()
table(dat_os$ARM)
View(Merge_TTFD)
# =============== OS ===============
## 2.1 取字段
dat_os <- Merge_TTFD %>%
select(UID, DTHDY, DTH, all_of(cov_OS)) %>%
distinct()
## 2.2 -999 清洗（其他列 -999→NA；不在此步显式 UNK）
dat_os <- dat_os %>%
mutate(across(all_of(cov_OS), ~ {
if (is.numeric(.x)) na_if(.x, -999) else factor(na_if(as.character(.x), "-999"))
}))
if (!is.numeric(dat_os$LESION1)) {
dat_os$LESION1 <- as.numeric(as.character(dat_os$LESION1))
}
med_lesion1 <- median(dat_os$LESION1, na.rm = TRUE)
dat_os$LESION1 <- ifelse(is.na(dat_os$LESION1) | dat_os$LESION1 == -999,
med_lesion1, dat_os$LESION1)
med_lesion1
## 2.3 仅保留完整行（时间/结局/所有协变量均非缺失）
dat_os <- dat_os %>%
filter(DTHDY != -999, DTH != -999, DTHDY > 0) %>%
drop_na(DTHDY, DTH, all_of(cov_OS)) %>%
droplevels()
## 2.3a 设参考（若存在这些水平）
if ("UNK" %in% levels(dat_os$EMPLOY))   dat_os$EMPLOY <- fct_relevel(dat_os$EMPLOY, "UNK", after = 0)
if ("Negative" %in% levels(dat_os$HER2)) dat_os$HER2   <- fct_relevel(dat_os$HER2, "Negative", after = 0)
dat_os$ECOG <- factor(dat_os$ECOG)
if ("0" %in% levels(dat_os$ECOG))        dat_os$ECOG   <- fct_relevel(dat_os$ECOG, "0", after = 0)
## 2.4 分类/连续类型确认（确保这些列是因子）
dat_os <- dat_os %>%
mutate(
STAGE  = as.factor(STAGE),
ARM    = as.factor(ARM),
EMPLOY = as.factor(EMPLOY),
ECOG   = as.factor(ECOG),
HER2   = as.factor(HER2)
# LESION1 如果本来是连续，就不要 factor；保留数值型即可
)
## 2.5 设计矩阵（去截距与零方差）
X_os <- model.matrix(~ ., data = dat_os %>% select(all_of(cov_OS)))
X_os <- X_os[, colnames(X_os) != "(Intercept)", drop = FALSE]
keep  <- apply(X_os, 2, function(z) sd(z, na.rm = TRUE) > 0)
X_os  <- X_os[, keep, drop = FALSE]
## 2.6 合成建模数据并拟合 Cox
stopifnot(nrow(dat_os) == nrow(X_os))
df_os_model <- cbind(dat_os[, c("DTHDY","DTH")], as.data.frame(X_os))
df_os_model <- df_os_model[, colSums(!is.na(df_os_model)) > 0, drop = FALSE]
df_os_model <- df_os_model[complete.cases(df_os_model), , drop = FALSE]
fit_os <- coxph(Surv(DTHDY, DTH) ~ ., data = df_os_model)
## 2.7 结果表（HR/95%CI/p）
tab_os <- tidy(fit_os, exponentiate = TRUE, conf.int = TRUE) %>%
mutate(term = sub("^X_", "", term)) %>%
select(term, HR = estimate, CI.low = conf.low, CI.high = conf.high, p.value)
## 2.8 加参考组（对每个因子，第一水平视为 ref，HR=1）
fac_vars_os <- cov_OS[sapply(cov_OS, function(v) is.factor(dat_os[[v]]))]
ref_rows_os <- map_dfr(fac_vars_os, function(v) tibble(
term   = paste0(v, levels(dat_os[[v]])[1], " (ref)"),
HR     = 1, CI.low = 1, CI.high = 1, p.value = NA_real_
))
tab_os_disp <- bind_rows(tab_os, ref_rows_os)
## 2.9 森林图（含参考组；参考组不画误差条）
p_os <- ggplot(tab_os_disp,
aes(y = reorder(term, HR, function(z) ifelse(is.na(z), 1, z)),
x = HR)) +
geom_point() +
geom_errorbarh(
data = filter(tab_os_disp, !is.na(CI.low)),
aes(xmin = CI.low, xmax = CI.high), height = 0.2
) +
geom_vline(xintercept = 1, linetype = 2, linewidth = 0.4) +
scale_x_log10() +
labs(x = "Hazard Ratio (log scale)", y = NULL,
title = "OS Forest Plot (with reference levels)") +
theme_classic(base_size = 12)
print(tab_os_disp)
print(p_os)
write_csv(tab_os_disp, "OS_forest_table_with_ref.csv")
